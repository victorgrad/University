package bussiness;

import domain.Tuple;
import domain.User;
import repository.database.FriendshipRepo;
import repository.database.UserRepo;

import java.util.*;

public class Network {
    private final UserRepo userRepository;
    private final FriendshipRepo friendshipRepo;

    /**
     * Class constructor
     * @param userRepository, an repository of Users with id-s represented as String
     */
    public Network(UserRepo userRepository, FriendshipRepo friendshipRepo){
        this.userRepository = userRepository;
        this.friendshipRepo = friendshipRepo;
    }

    /**
     * Comutes the connex component of the graph generated by the friendships between users
     * @return  a list of connex components that contain the users
     */
    public List<List<String>> getConnexComponents(){
        List<List<String>> components = new ArrayList<>();
        Set<String> explored = new HashSet<>();

        for(User user: userRepository.findAll()){
            String username = user.getId();

            if(!explored.contains(username)){
                Stack<String> stack = new Stack<>();
                List<String> connexComponent = new ArrayList<>();
                stack.push(username);
                explored.add(username);
                connexComponent.add(username);

                while (!stack.isEmpty()){
                    String currentUsername = stack.pop();

                    for(String adjacentUsername: friendshipRepo.getUserFriends(currentUsername)){
                        if(!explored.contains(adjacentUsername)){
                            stack.push(adjacentUsername);
                            explored.add(adjacentUsername);
                            connexComponent.add(adjacentUsername);
                        }
                    }
                }
                components.add(connexComponent);
            }
        }
        return components;
    }

    /**
     * Computes the diameter of the graph (the longest elementary path)
     * @param component a list of users that form a connex graph
     * @return the length of the path
     */
    private int sizeOfLongestPath(List<String> component){
        int longestPathSize = 0;

        for(String username: component){
            Stack<String> userStack = new Stack<>();
            Stack<Set<String>> visitedStack = new Stack<>();
            userStack.push(username);
            visitedStack.push(new HashSet<>());

            while(!userStack.isEmpty()){
                String currentUsername = userStack.pop();
                Set<String> currentVisited = visitedStack.pop();
                currentVisited.add(currentUsername);

                for(String adj: friendshipRepo.getUserFriends(currentUsername)){
                    boolean ok = false;
                    if(!currentVisited.contains(adj)){
                        userStack.push(adj);
                        visitedStack.push(new HashSet<>(currentVisited));
                        ok = true;
                    }
                    if(!ok){
                        if(currentVisited.size() > longestPathSize){
                            longestPathSize = currentVisited.size();
                        }
                    }
                }
            }
        }
        return longestPathSize;
    }

    /**
     * Finds the connex component in the graph with the largest diameter
     * @return a tuple of 2 values: an integer, the length of the longest elementary path
     */
    public Tuple<Integer, List<String>> getMostSociableComponent(){
        List<String> mostSociable = null;
        int longestPathSize = 0;

        for(List<String> component: getConnexComponents()){
            int localLongestPath = sizeOfLongestPath(component);
            if(localLongestPath > longestPathSize){
                longestPathSize = localLongestPath;
                mostSociable = component;
            }
        }
        return new Tuple<>(longestPathSize, mostSociable);
    }
}
